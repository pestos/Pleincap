---
phase: 03-migration-seo
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/scripts/seed/seed-cruises.ts
  - src/app/(frontend)/catalogue/page.tsx
  - src/app/(frontend)/catalogue/[slug]/page.tsx
  - src/app/(frontend)/catalogue/danube-imperial/page.tsx
autonomous: true

must_haves:
  truths:
    - "Cruises collection has data in database with relationships to boats, destinations, and speakers resolved"
    - "Catalogue listing page displays cruises from CMS"
    - "Dynamic cruise detail route /catalogue/[slug] renders individual cruises from CMS"
    - "URL /catalogue/danube-imperial works via dynamic route (not static file)"
    - "Existing URLs are preserved with no 404s"
  artifacts:
    - path: "src/scripts/seed/seed-cruises.ts"
      provides: "Migration script for cruises with itinerary data and relationship resolution"
    - path: "src/app/(frontend)/catalogue/page.tsx"
      provides: "Catalogue listing page fetching from CMS"
    - path: "src/app/(frontend)/catalogue/[slug]/page.tsx"
      provides: "Dynamic cruise detail page with itinerary, experts, pricing"
  key_links:
    - from: "src/scripts/seed/seed-cruises.ts"
      to: "payload.find collection:boats"
      via: "Relationship resolution by slug"
      pattern: "payload\\.find.*collection.*boats"
    - from: "src/app/(frontend)/catalogue/[slug]/page.tsx"
      to: "src/lib/payload-queries.ts"
      via: "getCruiseBySlug() import"
      pattern: "getCruiseBySlug"
    - from: "src/app/(frontend)/catalogue/page.tsx"
      to: "src/lib/payload-queries.ts"
      via: "getCruises() import"
      pattern: "getCruises"
---

<objective>
Seed cruises with relationships and convert the catalogue to dynamic CMS-driven pages.

Purpose: The catalogue is the most complex migration because cruises have relationships to boats, destinations, and speakers, plus itinerary arrays with day-by-day data. This plan seeds cruise data with proper relationship resolution and creates a dynamic `[slug]` route to replace the static `danube-imperial` page. The catalogue listing page is also converted to fetch from CMS.

Output: 1 seed script + 2 converted/new pages. The entire catalogue section is CMS-driven.
</objective>

<execution_context>
@/Users/fredericgueirard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fredericgueirard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-migration-seo/03-RESEARCH.md
@.planning/phases/03-migration-seo/03-01-SUMMARY.md
@.planning/phases/03-migration-seo/03-02-SUMMARY.md
@src/payload/collections/Cruises.ts
@src/lib/payload-queries.ts
@src/app/(frontend)/catalogue/page.tsx
@src/app/(frontend)/catalogue/danube-imperial/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Seed cruises with relationships and itinerary data</name>
  <files>src/scripts/seed/seed-cruises.ts</files>
  <action>
Create the seed script for Cruises. This is the most complex seed because cruises depend on boats, destinations, and speakers that must already exist in the database (seeded in 03-01 and 03-02).

**Data sources:** Extract cruise data from two files:
1. `src/app/(frontend)/catalogue/page.tsx` - the 4 cruise cards (listing data: title, route, departure, duration, ship, tag, region, price, image)
2. `src/app/(frontend)/catalogue/danube-imperial/page.tsx` - the detailed cruise page (itinerary days, experts, pricing categories, demeures)

**Relationship resolution strategy:**
For each cruise, resolve relationships by querying existing collections by slug:
```typescript
// Example: resolve boat
const boat = await payload.find({
  collection: 'boats',
  where: { name: { like: cruise.ship } },
})
const boatId = boat.docs[0]?.id
```

If a relationship cannot be resolved (boat/destination not found), log a warning but still create the cruise with the relationship field empty (since the field may not find a match for all cruises).

**Cruise data mapping:**
For each cruise from the catalogue listing:
- `title`: directly from hardcoded data
- `slug`: generate from title (e.g., "L'Odyssee des Dieux : Mythes de l'Egee" -> "l-odyssee-des-dieux-mythes-de-l-egee"). The formatSlug hook will handle this automatically.
- `excerpt`: use the description text
- `description`: richText from excerpt text
- `featuredImage`: upload from `image` URL
- `destination`: resolve by matching `region` to a destination, or by matching `route` text to a destination name
- `boat`: resolve by matching `ship` name to a boat name
- `departureDate`: parse from "14 Juin 2024" format
- `returnDate`: calculate from departureDate + duration days
- `price`: parse from "2,490 €" -> 2490
- `availableSpots`: default to 20
- `_status`: 'published'

**Danube Imperial detailed data:**
For the one cruise with detailed data (danube-imperial), also seed:
- `itinerary`: array of 5 days from the `itinerary` constant in danube-imperial/page.tsx
  - Each day: `day` (number), `title` (text), `description` (richText from desc), `highlights` (textarea, one per line from highlights array)
  - `images`: upload from day image URLs
- `speakers`: resolve speaker relationships from the `experts` array (match by name)

**Important:** The Cruises collection requires `description` (richText, required) and `featuredImage` (upload, required). Make sure these are always populated.

Check for duplicates by slug before creating. Log results.
  </action>
  <verify>
Run the seed script:
```bash
npx tsx src/scripts/seed/seed-cruises.ts
```
Verify:
```bash
curl http://localhost:3000/api/cruises | jq '.totalDocs'
curl "http://localhost:3000/api/cruises?where[slug][equals]=danube-imperial&depth=2" | jq '.docs[0].itinerary | length'
```
Expected: totalDocs >= 4, danube-imperial has 5 itinerary days with resolved boat/destination relationships.
  </verify>
  <done>
Database contains 4+ cruises with resolved relationships (boat, destination, speakers). The danube-imperial cruise has 5 itinerary days. Seed script is idempotent.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert catalogue listing and create dynamic [slug] route</name>
  <files>
    src/app/(frontend)/catalogue/page.tsx
    src/app/(frontend)/catalogue/[slug]/page.tsx
    src/app/(frontend)/catalogue/danube-imperial/page.tsx
  </files>
  <action>
Convert the catalogue section to be fully CMS-driven.

**Step 1: Convert catalogue/page.tsx (listing page)**
- Remove hardcoded `cruises` array and `CruiseCard` type
- Make `Catalogue` async Server Component
- Import `getCruises` from `@/lib/payload-queries`
- Fetch cruises: `const { docs: cruises } = await getCruises({ published: true })`
- Map CMS fields to JSX template:
  - `cruise.title` -> title
  - `cruise.slug` -> link href `/catalogue/${cruise.slug}`
  - `cruise.featuredImage?.url` -> image src
  - `cruise.price` -> format as "X,XXX €"
  - `cruise.departureDate` -> format as "DD Month YYYY" in French
  - `cruise.boat?.name` -> ship name (depth:2 populates relationship)
  - `cruise.destination?.name` -> destination display
  - `cruise.excerpt` -> description text
- The route map SVG overlays are decorative and specific to each cruise. Since they're JSX/SVG and not CMS data, remove them or replace with a simple "Voir l'itineraire" link.
- Keep FilterBlock component and filter sidebar - these become decorative for now (actual filtering requires client-side state, which can be added later). Alternatively, keep the sidebar static.
- Keep the metadata export
- Keep SiteHeader/SiteFooter wrapper

**Step 2: Create catalogue/[slug]/page.tsx (dynamic detail route)**
- Create new file `src/app/(frontend)/catalogue/[slug]/page.tsx`
- This replaces the static `danube-imperial/page.tsx` with a dynamic route
- Make it an async Server Component
- Import `getCruiseBySlug` from `@/lib/payload-queries`
- Fetch cruise by slug from params: `const cruise = await getCruiseBySlug(params.slug)`
- If not found, call `notFound()` from 'next/navigation'
- Replicate the layout from `danube-imperial/page.tsx` but with dynamic data:
  - Hero section with cruise title, dates, price
  - Itinerary timeline from `cruise.itinerary` array
  - Speakers/experts section from `cruise.speakers` relationship
  - Pricing section (if applicable)
- Add `generateStaticParams` to pre-render published cruise slugs:
  ```typescript
  export async function generateStaticParams() {
    const payload = await getPayloadClient()
    const { docs } = await payload.find({
      collection: 'cruises',
      where: { _status: { equals: 'published' } },
      select: { slug: true },
      pagination: false,
    })
    return docs.map((doc) => ({ slug: doc.slug }))
  }
  ```
- Add `generateMetadata` for SEO using cruise's meta fields (from SEO plugin) or fallback to title/excerpt

**Step 3: Remove static danube-imperial directory**
- Delete `src/app/(frontend)/catalogue/danube-imperial/page.tsx` and the directory
- The URL `/catalogue/danube-imperial` will now be served by the dynamic `[slug]` route

**URL preservation:** The slug "danube-imperial" must match what the seed script creates. Verify by checking the slug the formatSlug hook generates from "Le Danube Imperial : De Vienne a Belgrade". If needed, set the slug explicitly in the seed data to "danube-imperial" to preserve the URL.
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Visit http://localhost:3000/catalogue - should display cruises from CMS
3. Visit http://localhost:3000/catalogue/danube-imperial - should display the cruise detail page with itinerary from CMS
4. Verify no 404 on /catalogue/danube-imperial
5. Verify `danube-imperial` directory no longer exists
6. Run `npx next build` to verify build succeeds
7. Check that `generateStaticParams` generates correct slugs
  </verify>
  <done>
Catalogue listing page fetches cruises from CMS. Dynamic [slug] route renders individual cruise details. URL /catalogue/danube-imperial preserved via dynamic route. Static danube-imperial directory removed. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. Database has 4+ cruises with resolved relationships
2. /catalogue lists cruises from CMS
3. /catalogue/danube-imperial renders via dynamic route (not static file)
4. Itinerary days display correctly on detail page
5. No 404s on existing URLs
6. Build succeeds with generateStaticParams
</verification>

<success_criteria>
- Cruises seeded with relationships resolved to boats, destinations, speakers
- Catalogue listing is CMS-driven
- Dynamic [slug] route works for cruise details
- URL /catalogue/danube-imperial preserved
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-migration-seo/03-03-SUMMARY.md`
</output>
