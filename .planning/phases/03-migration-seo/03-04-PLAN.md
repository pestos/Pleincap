---
phase: 03-migration-seo
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - src/app/(frontend)/destinations/page.tsx
  - src/app/(frontend)/destinations/DestinationsClient.tsx
  - src/app/(frontend)/nos-bateaux/page.tsx
  - src/app/(frontend)/nos-bateaux/[slug]/page.tsx
  - src/app/(frontend)/nos-bateaux/amadeus-diamond/page.tsx
  - src/app/(frontend)/nos-bateaux/nile-excellence/page.tsx
  - src/app/(frontend)/blog/page.tsx
  - src/app/(frontend)/page.tsx
autonomous: true

must_haves:
  truths:
    - "Destinations page displays regions from CMS instead of hardcoded arrays"
    - "Boats listing page displays boats from CMS"
    - "Dynamic boat detail route /nos-bateaux/[slug] works for all boats"
    - "Blog page displays posts from CMS (or empty state if no posts seeded)"
    - "Homepage testimonials and featured cruises come from CMS"
    - "URLs /destinations, /nos-bateaux, /nos-bateaux/amadeus-diamond, /nos-bateaux/nile-excellence, /blog remain identical"
  artifacts:
    - path: "src/app/(frontend)/destinations/page.tsx"
      provides: "Destinations page with CMS data"
    - path: "src/app/(frontend)/nos-bateaux/page.tsx"
      provides: "Boats listing from CMS"
    - path: "src/app/(frontend)/nos-bateaux/[slug]/page.tsx"
      provides: "Dynamic boat detail page with specs and cabins"
    - path: "src/app/(frontend)/blog/page.tsx"
      provides: "Blog listing from CMS posts"
    - path: "src/app/(frontend)/page.tsx"
      provides: "Homepage with CMS-driven testimonials and cruises"
  key_links:
    - from: "src/app/(frontend)/nos-bateaux/[slug]/page.tsx"
      to: "src/lib/payload-queries.ts"
      via: "getBoatBySlug() import"
      pattern: "getBoatBySlug"
    - from: "src/app/(frontend)/blog/page.tsx"
      to: "src/lib/payload-queries.ts"
      via: "getPosts() import"
      pattern: "getPosts"
    - from: "src/app/(frontend)/page.tsx"
      to: "src/lib/payload-queries.ts"
      via: "getCruises() and getTestimonials() imports"
      pattern: "(getCruises|getTestimonials)"
---

<objective>
Convert remaining CMS-backed pages: Destinations, Boats (listing + dynamic detail), Blog, and Homepage sections.

Purpose: Complete the migration of all pages that have corresponding CMS collections. After this plan, all content that has a Payload collection will be served from the database. Pages without CMS collections (orient-express, escapades-culturelles, special-groupes, notre-histoire, voyages-en-train, visioconference, contact) remain static since they represent fixed marketing pages.

Output: 5 converted pages + 1 new dynamic route. All CMS-backed content is dynamic.
</objective>

<execution_context>
@/Users/fredericgueirard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fredericgueirard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-migration-seo/03-RESEARCH.md
@.planning/phases/03-migration-seo/03-02-SUMMARY.md
@.planning/phases/03-migration-seo/03-03-SUMMARY.md
@src/lib/payload-queries.ts
@src/app/(frontend)/destinations/page.tsx
@src/app/(frontend)/destinations/DestinationsClient.tsx
@src/app/(frontend)/nos-bateaux/page.tsx
@src/app/(frontend)/nos-bateaux/amadeus-diamond/page.tsx
@src/app/(frontend)/nos-bateaux/nile-excellence/page.tsx
@src/app/(frontend)/blog/page.tsx
@src/app/(frontend)/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert Destinations and Boats pages to CMS data</name>
  <files>
    src/app/(frontend)/destinations/page.tsx
    src/app/(frontend)/destinations/DestinationsClient.tsx
    src/app/(frontend)/nos-bateaux/page.tsx
    src/app/(frontend)/nos-bateaux/[slug]/page.tsx
    src/app/(frontend)/nos-bateaux/amadeus-diamond/page.tsx
    src/app/(frontend)/nos-bateaux/nile-excellence/page.tsx
  </files>
  <action>
**Destinations page:**
The destinations page has a Server Component (`page.tsx`) and a Client Component (`DestinationsClient.tsx`) for continent filtering.

Strategy: Fetch destinations server-side and pass as props to the client component.

1. In `destinations/page.tsx`:
   - Make async, import `getDestinations` from `@/lib/payload-queries`
   - Fetch: `const destinations = await getDestinations()`
   - Pass destinations to `DestinationsClient` as prop

2. In `DestinationsClient.tsx`:
   - Accept `destinations` prop instead of using hardcoded `regions` array
   - The `continents` array and `continentCopy` descriptions can remain hardcoded (they're UI labels, not CMS content)
   - Map CMS destination fields to the existing template:
     - `destination.name` -> region title
     - `destination.region` -> map to continent for filtering (mediterranee/europe-nord/europe-centrale -> Europe, afrique -> Afrique, asie -> Asie, autre -> Autre)
     - `destination.featuredImage?.url` -> image
     - `destination.excerpt` -> area description (or derive from region)
   - The `itineraries` count was hardcoded. Since we can't count cruises per destination without querying, set to 0 or omit. Alternatively, query cruises per destination server-side and pass counts.

3. Keep the Hero and TopItineraries sections static (they have hardcoded itinerary data that doesn't map to CMS collections)

**Boats listing page (`nos-bateaux/page.tsx`):**
1. Currently a client component with filtering. Strategy: fetch boats server-side, pass to client for filtering.
2. Remove `'use client'` from the wrapper, create a separate client component for filtering or pass boats as serialized prop.
3. Actually, since the boats listing page uses `useState` for filtering, keep it as `'use client'` but fetch boats server-side in a parent Server Component wrapper, or pass boats as a serialized prop. Simplest approach: make the page a Server Component that imports a Client Component.
4. Create the page as async Server Component that fetches boats and passes to a `BoatsClient` component (extracted from existing page).
5. Map: `boat.name`, `boat.capacity`, `boat.featuredImage?.url`, extract description text from richText for atmosphere.
6. The `tag` field (Fluvial/Maritime) is not in the Boats CMS collection. For now, derive from boat name or remove the filter. Since the CMS doesn't have a type field on boats, the filtering tabs can be removed or kept decorative.

**Boats dynamic detail (`nos-bateaux/[slug]/page.tsx`):**
1. Create `src/app/(frontend)/nos-bateaux/[slug]/page.tsx`
2. Import `getBoatBySlug` from query helpers
3. Fetch boat by slug, call `notFound()` if not found
4. Replicate the detail layout from `amadeus-diamond/page.tsx`:
   - Hero with boat image and name
   - Specifications (capacity, crew, length, built year, renovated year)
   - Cabin categories from `boat.cabins` array
   - Gallery if available
   - Deck plan if available
5. Add `generateStaticParams` for pre-rendering
6. Add `generateMetadata` using SEO plugin fields or boat name/description

**Remove static boat detail pages:**
- Delete `src/app/(frontend)/nos-bateaux/amadeus-diamond/` directory
- Delete `src/app/(frontend)/nos-bateaux/nile-excellence/` directory
- URLs preserved via dynamic [slug] route

**URL preservation:** Verify slugs match:
- "M/S Amadeus Diamond" -> formatSlug should produce "m-s-amadeus-diamond" or "ms-amadeus-diamond"
- Current URL is `/nos-bateaux/amadeus-diamond`
- The existing page links use: `ship.name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "").replace(/^(m-s-|ms-)/, "")`
- This means the URL strips the "m-s-" or "ms-" prefix! So the slug in the DB must be "amadeus-diamond" not "m-s-amadeus-diamond"
- **IMPORTANT:** When seeding boats, explicitly set slug to match existing URLs. For "M/S Amadeus Diamond" -> slug: "amadeus-diamond", for "M/S Nile Excellence" -> slug: "nile-excellence", etc.
- If the formatSlug hook would generate a different slug, override it in the seed script by setting the slug field explicitly.
  </action>
  <verify>
1. Visit http://localhost:3000/destinations - should show destinations from CMS
2. Visit http://localhost:3000/nos-bateaux - should list 4 boats from CMS
3. Visit http://localhost:3000/nos-bateaux/amadeus-diamond - should render via dynamic route
4. Visit http://localhost:3000/nos-bateaux/nile-excellence - should render via dynamic route
5. Verify static amadeus-diamond and nile-excellence directories are deleted
6. Run `npx next build` - should succeed
  </verify>
  <done>
Destinations page shows CMS data. Boats listing and detail pages are CMS-driven. Dynamic [slug] route replaces static boat pages. URLs /nos-bateaux/amadeus-diamond and /nos-bateaux/nile-excellence preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert Blog page and Homepage dynamic sections</name>
  <files>
    src/app/(frontend)/blog/page.tsx
    src/app/(frontend)/page.tsx
  </files>
  <action>
**Blog page (`blog/page.tsx`):**
1. Currently a `'use client'` component with useState for filtering/search
2. Strategy: The blog needs client-side interactivity for filtering. Create a Server Component wrapper that fetches posts and passes to a Client Component.
3. Or simpler: since the blog may have 0 posts initially (posts were hardcoded but not seeded into CMS), make the page handle empty state gracefully.
4. Actually, the blog posts in the hardcoded data are sample/placeholder content. The research says "leave empty; let content team create posts naturally." So the blog page should:
   - Fetch posts from CMS: `const { docs: posts } = await getPosts({ limit: 20 })`
   - If posts exist, display them in the same grid layout
   - If no posts, display a friendly empty state message
   - Categories should come from the Categories collection (query them server-side)
5. Remove the hardcoded `blogPosts` and `categories` arrays
6. The filtering/search requires client-side state. Create a wrapper pattern:
   - `blog/page.tsx` (Server Component): fetches posts and categories, passes to BlogClient
   - `blog/BlogClient.tsx` (Client Component): receives posts as prop, handles filtering/search locally
7. Map: `post.title`, `post.excerpt` or extract from content, `post.featuredImage?.url`, `post.categories` relationship, `post.author?.name` or `post.author?.email`, `post.publishedDate` -> format, `post.slug` -> link href
8. If no posts exist in CMS yet, the page shows empty state - this is correct behavior.

**Homepage (`page.tsx`):**
The homepage has several sections. Only convert sections that map to CMS collections:

1. **Selection section** (3 cruise cards): Replace hardcoded cruise cards with CMS data
   - Fetch featured/latest cruises: `const { docs: featuredCruises } = await getCruises({ published: true, limit: 3 })`
   - Map cruise fields to the card template (image, title, boat name, price, dates)
   - Link cards to `/catalogue/${cruise.slug}`

2. **Testimonials section** (1 testimonial): Replace with CMS testimonial
   - Fetch featured testimonial: `const testimonials = await getTestimonials({ featured: true })`
   - Display the first featured testimonial
   - Map: `testimonial.content` -> quote text, `testimonial.authorName` -> author

3. **Keep hardcoded:** Hero video, search box, intro text, grid categories, trust marks - these are fixed design elements, not CMS content

4. Make the homepage async to fetch data
5. The homepage currently has no `'use client'` directive (good - it's a Server Component by default)

**CRITICAL:** The homepage is 487 lines of JSX. Be careful to ONLY modify the data source for the Selection and Testimonials sections. Do NOT change any layout, classes, or structure of other sections.
  </action>
  <verify>
1. Visit http://localhost:3000/blog - should handle empty state or display posts if seeded
2. Visit http://localhost:3000/ - homepage should show cruises in Selection section from CMS
3. Homepage testimonial section should display CMS testimonial
4. All other homepage sections unchanged
5. Run `npx next build` - should succeed
  </verify>
  <done>
Blog page fetches posts from CMS (handles empty state). Homepage Selection section displays cruises from CMS. Homepage testimonial section displays CMS testimonial. All other page sections unchanged. URLs preserved.
  </done>
</task>

</tasks>

<verification>
1. /destinations shows CMS data
2. /nos-bateaux lists boats from CMS
3. /nos-bateaux/amadeus-diamond renders via dynamic route
4. /nos-bateaux/nile-excellence renders via dynamic route
5. /blog handles empty state or shows CMS posts
6. Homepage shows CMS cruises in Selection section
7. Homepage shows CMS testimonial
8. All existing URLs preserved (no 404s)
9. Build succeeds
</verification>

<success_criteria>
- All pages with CMS collections display dynamic data
- No hardcoded content arrays remain in converted pages
- Dynamic routes work for boats
- Blog handles empty CMS gracefully
- Homepage partially dynamic (cruises, testimonials)
- All URLs preserved
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-migration-seo/03-04-SUMMARY.md`
</output>
