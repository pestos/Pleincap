---
phase: 03-migration-seo
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/scripts/seed/seed-speakers.ts
  - src/scripts/seed/seed-team.ts
  - src/scripts/seed/seed-testimonials.ts
  - src/lib/payload-queries.ts
autonomous: true

must_haves:
  truths:
    - "Speakers, Team, and Testimonials collections have data in the database after running seed scripts"
    - "Payload Local API query helpers return typed data for all seeded collections"
    - "Seed scripts are idempotent (running twice does not create duplicates)"
  artifacts:
    - path: "src/scripts/seed/seed-speakers.ts"
      provides: "Migration script for 6 speakers from nos-conferenciers page"
    - path: "src/scripts/seed/seed-team.ts"
      provides: "Migration script for 7 team members from equipe page"
    - path: "src/scripts/seed/seed-testimonials.ts"
      provides: "Migration script for 6 testimonials from livre-d-or page"
    - path: "src/lib/payload-queries.ts"
      provides: "Reusable typed query functions using Payload Local API"
  key_links:
    - from: "src/scripts/seed/*.ts"
      to: "payload.create"
      via: "Payload Local API"
      pattern: "payload\\.create\\(\\{\\s*collection:"
    - from: "src/lib/payload-queries.ts"
      to: "payload.find"
      via: "Payload Local API"
      pattern: "payload\\.find\\(\\{\\s*collection:"
---

<objective>
Create seed scripts for independent collections (Speakers, Team, Testimonials) and establish reusable Payload Local API query helpers.

Purpose: Build the migration infrastructure and seed the first batch of collections that have no dependencies on other collections. These seed scripts extract hardcoded data from page components and insert it into the Payload CMS database. The query helpers provide a reusable, typed interface for fetching CMS data in Server Components.

Output: 3 seed scripts + 1 query helper library. Database populated with speakers, team members, and testimonials.
</objective>

<execution_context>
@/Users/fredericgueirard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fredericgueirard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-migration-seo/03-RESEARCH.md
@src/payload/collections/Speakers.ts
@src/payload/collections/Team.ts
@src/payload/collections/Testimonials.ts
@src/app/(frontend)/nos-conferenciers/page.tsx
@src/app/(frontend)/equipe/page.tsx
@src/app/(frontend)/livre-d-or/page.tsx
@payload.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Payload Local API query helpers library</name>
  <files>src/lib/payload-queries.ts</files>
  <action>
Create `src/lib/payload-queries.ts` with reusable query functions using Payload's Local API. This file will be imported by all Server Components that need CMS data.

Use the pattern from research: `import { getPayload } from 'payload'` and `import config from '@payload-config'`.

Create a helper `getPayloadClient()` that initializes and caches the Payload instance:

```typescript
import { getPayload } from 'payload'
import config from '@payload-config'

export const getPayloadClient = () => getPayload({ config })
```

Then create typed query functions for each collection:

1. `getSpeakers()` - Returns all speakers, sorted by name
2. `getTeamMembers()` - Returns all team members, sorted by `order` field
3. `getTestimonials(options?: { featured?: boolean })` - Returns testimonials, optionally filtered by `featured` flag
4. `getCruises(options?: { published?: boolean, limit?: number, page?: number })` - Returns cruises with depth:2 to populate boat/destination/speakers relationships
5. `getCruiseBySlug(slug: string)` - Returns single cruise by slug with depth:2
6. `getDestinations()` - Returns all destinations
7. `getBoats()` - Returns all boats
8. `getBoatBySlug(slug: string)` - Returns single boat by slug
9. `getPosts(options?: { limit?: number, page?: number, category?: string })` - Returns published posts with depth:1
10. `getPostBySlug(slug: string)` - Returns single post by slug with depth:1

Each function should:
- Use `getPayloadClient()` to get the Payload instance
- Set appropriate `depth` for relationship population (depth:2 for cruises, depth:1 for posts)
- Filter by `_status: 'published'` for collections with draft/publish workflow (cruises, posts)
- Use `pagination: false` for small collections (speakers, team, testimonials, destinations, boats)
- Return typed results

Note: Do NOT use REST API. Local API is the correct pattern for Server Components (no HTTP overhead, type-safe).
  </action>
  <verify>
Run `npx tsc --noEmit src/lib/payload-queries.ts` to verify TypeScript compilation without errors. If the project uses strict types, the file should compile cleanly.
  </verify>
  <done>
`src/lib/payload-queries.ts` exports typed query functions for all collections. Each function uses Payload Local API with appropriate depth and filtering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create seed scripts for Speakers, Team, and Testimonials</name>
  <files>
    src/scripts/seed/seed-speakers.ts
    src/scripts/seed/seed-team.ts
    src/scripts/seed/seed-testimonials.ts
  </files>
  <action>
Create 3 seed scripts that extract the hardcoded data from existing page components and insert it into Payload CMS via the Local API.

**IMPORTANT: Image handling strategy.** Images are currently external URLs (plein-cap.com, googleusercontent.com). Do NOT upload them to Payload Media for this plan. Instead, for the `photo`/`authorPhoto` fields (which are `upload` type requiring Media collection references), skip populating image fields in the seed scripts. The team will add images via the admin UI later. This avoids the complexity of downloading and re-uploading external images programmatically. Mark fields that reference media as optional or handle gracefully.

**Actually, re-reading the collections:** The `photo` field on Speakers is `required: true`, and `photo` on Team is `required: true`. We need to handle this. The approach: create a seed helper that downloads an image from the external URL and uploads it to the Media collection via `payload.create({ collection: 'media', ... })`, then uses the returned ID. Use node `fetch` to download the image buffer.

Create a shared helper `src/scripts/seed/utils.ts`:
```typescript
export async function uploadMediaFromUrl(payload, url: string, alt: string): Promise<number> {
  const response = await fetch(url)
  const buffer = Buffer.from(await response.arrayBuffer())
  const filename = alt.toLowerCase().replace(/[^a-z0-9]+/g, '-') + '.jpg'

  // Check if media with this filename already exists
  const existing = await payload.find({
    collection: 'media',
    where: { filename: { equals: filename } },
  })
  if (existing.docs.length > 0) return existing.docs[0].id

  const media = await payload.create({
    collection: 'media',
    data: { alt },
    file: { data: buffer, mimetype: 'image/jpeg', name: filename, size: buffer.length },
  })
  return media.id
}
```

**seed-speakers.ts**: Extract the 6 experts from `nos-conferenciers/page.tsx`:
- Map each expert's `name`, `title` (as `specialty`), `desc` (as `bio` in richText format), `image` (as `photo` via upload)
- `bio` must be richText format. Use a simple root node with a single paragraph containing the text:
  ```typescript
  { root: { type: 'root', children: [{ type: 'paragraph', children: [{ type: 'text', text: expert.desc }] }] } }
  ```
- Check for duplicates by slug before creating
- Log results with counts (created, skipped, errors)

**seed-team.ts**: Extract the 7 team members from `equipe/page.tsx`:
- Map each member's `name`, `role` (as `jobTitle`), `longBio` (as `bio` in richText format), `image` (as `photo` via upload)
- Set `order` field based on array index
- `quote` field from the hardcoded data has no matching Payload field - skip it (it's baked into the page template)
- Check for duplicates by slug before creating

**seed-testimonials.ts**: Extract the 6 reviews from `livre-d-or/page.tsx`:
- Map each review's `author` (as `authorName`), `text` (as `content`), `meta` (parse to extract `cruiseName` and `date`)
- `image` field (as `authorPhoto` via upload) - only some reviews have images, handle null gracefully
- Set `rating` to 5 (default since reviews don't have explicit ratings)
- Set `featured` to true for the first 3 (those with images)
- Check for duplicates by authorName before creating

Each script should:
1. Import `getPayload` from 'payload' and config
2. Extract hardcoded data as constants
3. Run migration with validation and duplicate checking
4. Print summary (total, created, skipped, errors)
5. Be runnable via `npx tsx src/scripts/seed/seed-speakers.ts`
  </action>
  <verify>
Run each seed script sequentially:
```bash
npx tsx src/scripts/seed/seed-speakers.ts
npx tsx src/scripts/seed/seed-team.ts
npx tsx src/scripts/seed/seed-testimonials.ts
```
Each should print a summary with 0 errors. Running again should show all items skipped (idempotent).
Verify data exists by querying:
```bash
curl http://localhost:3000/api/speakers | jq '.totalDocs'
curl http://localhost:3000/api/team | jq '.totalDocs'
curl http://localhost:3000/api/testimonials | jq '.totalDocs'
```
Expected: speakers=6, team=7, testimonials=6
  </verify>
  <done>
Database contains 6 speakers, 7 team members, and 6 testimonials. Seed scripts are idempotent. Data matches the hardcoded content from page components.
  </done>
</task>

</tasks>

<verification>
1. `src/lib/payload-queries.ts` exports functions for all collections
2. Database has 6 speakers with photos uploaded to Media collection
3. Database has 7 team members with photos and correct order values
4. Database has 6 testimonials with correct author names and content
5. Running seed scripts twice produces 0 duplicates
6. TypeScript compilation succeeds without errors
</verification>

<success_criteria>
- Query helpers library exists and compiles
- All 3 seed scripts run successfully with 0 errors
- Database populated with correct data counts (6+7+6 = 19 documents)
- Seed scripts are idempotent (no duplicates on re-run)
</success_criteria>

<output>
After completion, create `.planning/phases/03-migration-seo/03-01-SUMMARY.md`
</output>
