---
phase: 04-newsletter-foundation
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/payload/lib/validation/csvValidator.ts
  - src/app/api/admin/subscribers/import/route.ts
  - src/app/api/admin/subscribers/export/route.ts
  - src/payload/collections/EmailAnalytics.ts
  - src/app/api/tracking/pixel.gif/route.ts
  - src/app/api/tracking/click/route.ts
  - payload.config.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Admin can import subscribers from a CSV file with email validation and duplicate detection"
    - "Admin can export the subscriber list as a CSV file"
    - "Email opens are tracked via a transparent tracking pixel"
    - "Email link clicks are tracked via redirect URLs"
    - "Analytics events are stored with campaign, subscriber, and timestamp"
  artifacts:
    - path: "src/payload/lib/validation/csvValidator.ts"
      provides: "CSV parsing and validation with PapaParse + Zod"
      exports: ["validateSubscriberCSV", "ValidationResult"]
    - path: "src/app/api/admin/subscribers/import/route.ts"
      provides: "POST endpoint for CSV file upload and subscriber import"
      exports: ["POST"]
    - path: "src/app/api/admin/subscribers/export/route.ts"
      provides: "GET endpoint for CSV subscriber list export"
      exports: ["GET"]
    - path: "src/payload/collections/EmailAnalytics.ts"
      provides: "Analytics events collection (open, click, unsubscribe, bounce)"
      contains: "slug: 'email-analytics'"
    - path: "src/app/api/tracking/pixel.gif/route.ts"
      provides: "Transparent GIF endpoint that records email open events"
      exports: ["GET"]
    - path: "src/app/api/tracking/click/route.ts"
      provides: "Click tracking redirect endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/admin/subscribers/import/route.ts"
      to: "src/payload/lib/validation/csvValidator.ts"
      via: "validateSubscriberCSV() for CSV validation before import"
      pattern: "validateSubscriberCSV"
    - from: "src/app/api/admin/subscribers/import/route.ts"
      to: "payload.create({ collection: 'subscribers' })"
      via: "Creating validated subscribers from CSV rows"
      pattern: "payload\\.create.*subscribers"
    - from: "src/app/api/tracking/pixel.gif/route.ts"
      to: "payload.create({ collection: 'email-analytics' })"
      via: "Recording open events"
      pattern: "email-analytics.*open"
    - from: "src/app/api/tracking/click/route.ts"
      to: "payload.create({ collection: 'email-analytics' })"
      via: "Recording click events before redirect"
      pattern: "email-analytics.*click"
---

<objective>
Create CSV import/export for subscriber management and email analytics tracking infrastructure (open/click tracking).

Purpose: Admin needs to manage subscriber lists via CSV (NEWS-02) and track email engagement for campaign effectiveness. Analytics tracking routes are referenced by campaign email templates.
Output: Working CSV import/export endpoints and email analytics tracking system.
</objective>

<execution_context>
@/Users/fredericgueirard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fredericgueirard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-newsletter-foundation/04-RESEARCH.md
@.planning/phases/04-newsletter-foundation/04-01-SUMMARY.md
@payload.config.ts
@src/payload/collections/Subscribers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: CSV import/export with validation</name>
  <files>
    package.json
    src/payload/lib/validation/csvValidator.ts
    src/app/api/admin/subscribers/import/route.ts
    src/app/api/admin/subscribers/export/route.ts
  </files>
  <action>
**Step 1: Install PapaParse**
```bash
npm install papaparse zod
npm install --save-dev @types/papaparse
```
Note: zod may already be installed as a Payload dependency. Check first -- if already present, skip.

**Step 2: Create CSV validator** at `src/payload/lib/validation/csvValidator.ts`

Define Zod schema for subscriber rows:
```typescript
const SubscriberRowSchema = z.object({
  email: z.string().email('Format email invalide'),
  firstName: z.string().optional().default(''),
  lastName: z.string().optional().default(''),
})
```

Export `ValidationResult` interface:
```typescript
export interface ValidationResult {
  valid: Array<{ email: string, firstName?: string, lastName?: string }>
  errors: Array<{ row: number, email: string, error: string }>
  stats: { total: number, valid: number, invalid: number, duplicates: number }
}
```

Export `validateSubscriberCSV(csvContent: string): ValidationResult` function:
- Parse with PapaParse: `Papa.parse(csvContent, { header: true, skipEmptyLines: true, transformHeader: (h) => h.trim().toLowerCase() })`
- Map common header variations: 'e-mail' -> 'email', 'prenom' -> 'firstName', 'nom' -> 'lastName', 'first_name' -> 'firstName', 'last_name' -> 'lastName'
- Validate each row with Zod schema
- Track duplicates within file using Set of lowercase emails
- Sanitize against CSV injection: strip leading =, +, -, @ from all fields
- Return ValidationResult with stats

**Step 3: Create POST /api/admin/subscribers/import route**

`src/app/api/admin/subscribers/import/route.ts`:
- Require authentication: check `req.user` via Payload headers (use getPayload and check if user is authenticated)
- Accept FormData with 'file' field
- Validate file: must be CSV, max 5MB
- Read file content as text
- Call `validateSubscriberCSV(csvContent)`
- If no valid rows: return 400 with errors and stats
- For each valid row:
  - Check if email exists in subscribers collection
  - If exists: add to skipped list with reason
  - If new: create subscriber with status 'pending', source: 'import'
  - Do NOT trigger double opt-in for imports (imported subscribers are set to 'active' directly since they come from an existing list the admin manages -- admin takes responsibility)
  - Actually, set imported subscribers to status 'active' with subscribedAt: now, source: 'import'. The admin importing a CSV is asserting consent was already collected. Generate unsubscribeToken for each.
- Return 200 with: `{ success: true, imported: number, skipped: number, errors: number, stats, details: { skipped, errors } }`

For authentication check, use this pattern (consistent with how Payload admin API routes work):
```typescript
import { getPayload } from 'payload'
import config from '@payload-config'

const payload = await getPayload({ config })
// Check for auth header and verify user
const { user } = await payload.auth({ headers: request.headers })
if (!user) {
  return NextResponse.json({ error: 'Non autorise' }, { status: 401 })
}
```

If the above auth pattern doesn't work with Payload 3.x API, fall back to checking for a cookie-based session or Authorization header manually. Document the approach used.

**Step 4: Create GET /api/admin/subscribers/export route**

`src/app/api/admin/subscribers/export/route.ts`:
- Require authentication (same pattern as import)
- Query all subscribers: `payload.find({ collection: 'subscribers', limit: 0, pagination: false })`
- Convert to CSV using PapaParse: `Papa.unparse(data, { columns: ['email', 'firstName', 'lastName', 'status', 'subscribedAt', 'source'] })`
- Return as downloadable CSV:
  ```typescript
  return new NextResponse(csvContent, {
    headers: {
      'Content-Type': 'text/csv',
      'Content-Disposition': `attachment; filename="subscribers-${new Date().toISOString().split('T')[0]}.csv"`,
    }
  })
  ```
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors. Verify CSV validator handles edge cases (empty rows, missing headers, duplicate emails). Verify import/export routes require authentication.
  </verify>
  <done>
CSV validator parses and validates subscriber data with Zod, handles header variations, deduplicates, and sanitizes CSV injection. Import route creates subscribers from valid CSV rows (active status, skips existing). Export route returns all subscribers as downloadable CSV. Both routes require admin authentication. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Email analytics collection and tracking routes</name>
  <files>
    src/payload/collections/EmailAnalytics.ts
    src/app/api/tracking/pixel.gif/route.ts
    src/app/api/tracking/click/route.ts
    payload.config.ts
  </files>
  <action>
**Step 1: Create EmailAnalytics collection** at `src/payload/collections/EmailAnalytics.ts`

- slug: 'email-analytics'
- admin: { group: 'Newsletter', defaultColumns: ['event', 'campaign', 'subscriber', 'createdAt'] }
- Fields:
  - `event`: type select, required, index: true, options: [
      { label: 'Ouverture', value: 'open' },
      { label: 'Clic', value: 'click' },
      { label: 'Desinscription', value: 'unsubscribe' },
      { label: 'Rebond', value: 'bounce' }
    ]
  - `campaign`: type relationship, relationTo: 'campaigns', index: true
  - `subscriber`: type relationship, relationTo: 'subscribers', index: true
  - `url`: type text, admin: { condition: (data) => data?.event === 'click', description: 'URL cliquee' }
  - `ipAddress`: type text, admin: { readOnly: true }
  - `userAgent`: type text, admin: { readOnly: true }
- access: admin-only read, no public create/update/delete. The tracking routes use Payload Local API (server-side) to create records, so no public collection access needed.
- timestamps: true (Payload adds createdAt/updatedAt by default)

**Step 2: Register EmailAnalytics in payload.config.ts**
- Import `{ EmailAnalytics }` from './src/payload/collections/EmailAnalytics'
- Add to collections array

**Step 3: Create tracking pixel route** at `src/app/api/tracking/pixel.gif/route.ts`

Note: The directory name includes ".gif" -- Next.js App Router handles this as a route segment.

- Define the 1x1 transparent GIF as a Buffer constant:
  ```typescript
  const TRANSPARENT_GIF = Buffer.from(
    'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
    'base64'
  )
  ```
- GET handler:
  - Read `c` (campaignId) and `s` (subscriberId) from URL search params
  - If both present:
    - Use Payload Local API to create email-analytics record with event: 'open'
    - Capture ipAddress and userAgent from headers
    - Use try/catch -- tracking must not fail the pixel response
  - Always return the transparent GIF with headers:
    - 'Content-Type': 'image/gif'
    - 'Cache-Control': 'no-cache, no-store, must-revalidate'
    - 'Pragma': 'no-cache'
    - 'Expires': '0'
  - This is a public route (no auth) -- it's embedded in emails

NOTE: If the directory name `pixel.gif` causes issues with Next.js App Router (the `.` in folder name), use `pixel` instead and serve the GIF from `/api/tracking/pixel?c=...&s=...`. Document which approach was used.

**Step 4: Create click tracking route** at `src/app/api/tracking/click/route.ts`

- GET handler:
  - Read `c` (campaignId), `s` (subscriberId), `url` (target URL) from search params
  - Validate `url` is present and is a valid URL (starts with http:// or https://)
  - If campaignId and subscriberId present:
    - Create email-analytics record with event: 'click', url field populated
    - Capture ipAddress and userAgent
    - Use try/catch -- tracking must not fail the redirect
  - Redirect to the target URL: `NextResponse.redirect(url)`
  - If no url param: return 400 `{ error: 'URL requise' }`
  - This is a public route (no auth) -- it's embedded in emails

SECURITY: Validate the redirect URL to prevent open redirect attacks. Only allow URLs starting with 'https://' or 'http://'. Do NOT allow javascript:, data:, or relative URLs.
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors. Verify:
1. EmailAnalytics collection registered under Newsletter group
2. Tracking pixel route returns a valid GIF image
3. Click tracking route validates URL and redirects
4. Both tracking routes create analytics records via Payload Local API
  </verify>
  <done>
EmailAnalytics collection stores open/click/unsubscribe/bounce events with campaign and subscriber relationships. Tracking pixel returns transparent GIF and records opens. Click tracker records clicks and redirects to target URL with security validation. All tracking routes are public (embedded in emails). Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. CSV import validates rows, handles duplicates, sanitizes injection
3. CSV export produces valid CSV with subscriber data
4. Import/export routes require admin authentication
5. EmailAnalytics collection stores events with relationships
6. Tracking pixel returns valid 1x1 GIF
7. Click tracking validates URL before redirect (no open redirect)
8. All new collections registered in Payload config
</verification>

<success_criteria>
- Admin can upload a CSV file and see import results (imported, skipped, errors)
- Admin can download subscriber list as CSV
- Tracking pixel is embeddable in campaign emails (1x1 transparent GIF)
- Click tracking redirects work and record events
- Analytics events are queryable by campaign and subscriber
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-newsletter-foundation/04-03-SUMMARY.md`
</output>
