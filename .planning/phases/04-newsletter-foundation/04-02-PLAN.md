---
phase: 04-newsletter-foundation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/payload/collections/Campaigns.ts
  - src/payload/collections/CampaignSends.ts
  - src/payload/emails/CampaignTemplate.tsx
  - src/payload/jobs/sendCampaign.ts
  - payload.config.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create email campaigns with name, subject, content, and template selection"
    - "Admin can set campaign status to 'ready-to-send' to trigger sending"
    - "Campaign is sent to all active subscribers (or filtered segment) via background job"
    - "Each campaign send is tracked with sent/failed counts and completion status"
    - "Every sent email includes a one-click unsubscribe link (GDPR)"
  artifacts:
    - path: "src/payload/collections/Campaigns.ts"
      provides: "Campaign collection with name, subject, content, status, template fields"
      contains: "slug: 'campaigns'"
    - path: "src/payload/collections/CampaignSends.ts"
      provides: "Campaign send tracking with status, counts, timestamps"
      contains: "slug: 'campaign-sends'"
    - path: "src/payload/emails/CampaignTemplate.tsx"
      provides: "React Email campaign template with PleinCap branding and unsubscribe link"
    - path: "src/payload/jobs/sendCampaign.ts"
      provides: "Background task that sends campaign emails in batches"
    - path: "payload.config.ts"
      provides: "Updated config with Campaigns, CampaignSends collections and jobs queue"
  key_links:
    - from: "payload.config.ts"
      to: "src/payload/jobs/sendCampaign.ts"
      via: "Jobs queue task registration"
      pattern: "jobs.*tasks"
    - from: "src/payload/collections/Campaigns.ts"
      to: "payload.jobs.queue"
      via: "afterChange hook queues sendCampaign job when status is ready-to-send"
      pattern: "ready-to-send"
    - from: "src/payload/jobs/sendCampaign.ts"
      to: "src/payload/lib/email/emailAdapter.ts"
      via: "getEmailAdapter() for actual email delivery"
      pattern: "getEmailAdapter"
    - from: "src/payload/jobs/sendCampaign.ts"
      to: "src/payload/emails/CampaignTemplate.tsx"
      via: "render() to produce HTML for each subscriber"
      pattern: "render.*CampaignTemplate|CampaignEmail"
---

<objective>
Create the campaign management system: Campaigns and CampaignSends collections, React Email campaign template, and async sending via Payload's jobs queue.

Purpose: Enables admin to create, manage, and send newsletter campaigns to subscribers. Uses background processing to handle large subscriber lists without API timeouts.
Output: Working campaign creation and sending pipeline from admin panel to subscriber inboxes.
</objective>

<execution_context>
@/Users/fredericgueirard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fredericgueirard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-newsletter-foundation/04-RESEARCH.md
@.planning/phases/04-newsletter-foundation/04-01-SUMMARY.md
@payload.config.ts
@src/payload/collections/Subscribers.ts
@src/payload/lib/email/emailAdapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Campaigns and CampaignSends collections</name>
  <files>
    src/payload/collections/Campaigns.ts
    src/payload/collections/CampaignSends.ts
    payload.config.ts
  </files>
  <action>
**Step 1: Create Campaigns collection** at `src/payload/collections/Campaigns.ts`

Follow existing collection patterns. Use tabs layout (like Posts.ts) since there are many fields.

Collection config:
- slug: 'campaigns'
- admin: { useAsTitle: 'name', group: 'Newsletter', defaultColumns: ['name', 'status', 'sentAt', 'recipientCount', 'updatedAt'] }
- versions: { drafts: { autosave: { interval: 375 } } } (consistent with Posts pattern)
- Fields organized in tabs:
  - Tab "Contenu":
    - `name`: type text, required, label: 'Nom de la campagne'
    - `subject`: type text, required, maxLength: 100, label: 'Objet de l\'email', admin: { description: "L'objet affiché dans la boîte de réception" }
    - `preheader`: type text, maxLength: 150, label: 'Texte d\'aperçu', admin: { description: 'Texte affiché après l\'objet dans les clients email' }
    - `content`: type richText, required, label: 'Contenu de la campagne'
    - `featuredImage`: type upload, relationTo: 'media', label: 'Image principale'
  - Tab "Envoi":
    - `template`: type select, required, defaultValue: 'newsletter', options: [
        { label: 'Newsletter Standard', value: 'newsletter' },
        { label: 'Annonce', value: 'announcement' },
        { label: 'Promotion', value: 'promotion' }
      ]
    - `status`: type select, required, defaultValue: 'draft', options: [
        { label: 'Brouillon', value: 'draft' },
        { label: 'Prêt à envoyer', value: 'ready-to-send' },
        { label: 'En cours d\'envoi', value: 'sending' },
        { label: 'Envoyé', value: 'sent' },
        { label: 'Échoué', value: 'failed' }
      ], admin: { description: 'Passez à "Prêt à envoyer" pour déclencher l\'envoi' }
    - `sendToAll`: type checkbox, defaultValue: true, label: 'Envoyer à tous les abonnés actifs'
    - `testEmail`: type email, label: 'Email de test', admin: { description: 'Envoyer un test à cette adresse avant l\'envoi réel' }
  - Tab "Statistiques" (read-only):
    - `sentAt`: type date, admin: { readOnly: true }, label: 'Envoyé le'
    - `recipientCount`: type number, admin: { readOnly: true }, label: 'Nombre de destinataires'
    - `sentCount`: type number, admin: { readOnly: true }, label: 'Emails envoyés'
    - `failedCount`: type number, admin: { readOnly: true }, label: 'Emails échoués'

- access: admin-only for all operations (read/create/update/delete require `!!req.user`)
- hooks.afterChange: When status changes to 'ready-to-send' on update:
  1. Count active subscribers: `payload.count({ collection: 'subscribers', where: { status: { equals: 'active' } } })`
  2. Update campaign with recipientCount
  3. Queue the sendCampaign job: `await req.payload.jobs.queue({ task: 'sendCampaign', input: { campaignId: doc.id } })`
  4. Update campaign status to 'sending'

IMPORTANT: The afterChange hook should check `operation === 'update'` AND `doc.status === 'ready-to-send'` AND `previousDoc?.status !== 'ready-to-send'` to prevent re-queuing on subsequent saves. Use the `previousDoc` parameter available in afterChange hooks.

**Step 2: Create CampaignSends collection** at `src/payload/collections/CampaignSends.ts`

- slug: 'campaign-sends'
- admin: { group: 'Newsletter', defaultColumns: ['campaign', 'status', 'sentCount', 'failedCount', 'completedAt'] }
- Fields:
  - `campaign`: type relationship, relationTo: 'campaigns', required
  - `status`: type select, required, defaultValue: 'queued', options: ['queued', 'sending', 'completed', 'failed']
  - `totalRecipients`: type number, admin: { readOnly: true }
  - `sentCount`: type number, defaultValue: 0, admin: { readOnly: true }
  - `failedCount`: type number, defaultValue: 0, admin: { readOnly: true }
  - `startedAt`: type date, admin: { readOnly: true }
  - `completedAt`: type date, admin: { readOnly: true }
  - `errorLog`: type textarea, admin: { readOnly: true, rows: 5 }
- access: admin-only read/write

**Step 3: Register both collections in payload.config.ts**
- Import `{ Campaigns }` and `{ CampaignSends }`
- Add both to collections array
- NOTE: Do NOT configure jobs queue in this task -- that's Task 2. Just register the collections.
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors. Verify both collections are registered. Check that Campaigns has the afterChange hook with the status check.
  </verify>
  <done>
Campaigns collection exists with tabs layout (Contenu/Envoi/Statistiques), draft workflow, and afterChange hook that triggers sending. CampaignSends tracks execution progress. Both registered in Payload config under 'Newsletter' group. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create campaign email template and jobs queue sending task</name>
  <files>
    src/payload/emails/CampaignTemplate.tsx
    src/payload/jobs/sendCampaign.ts
    payload.config.ts
  </files>
  <action>
**Step 1: Create CampaignTemplate** at `src/payload/emails/CampaignTemplate.tsx`

Use @react-email/components. Props interface:
```typescript
interface CampaignEmailProps {
  preheader?: string
  heading: string
  content: string  // HTML content from rich text
  ctaText?: string
  ctaUrl?: string
  campaignId: string
  subscriberId: string
  unsubscribeUrl: string
  baseUrl: string
}
```

Template structure:
- PleinCap branding header with logo (use `${baseUrl}/logo.png` or text fallback "PleinCap Croisieres")
- Colors: primary #C5A059, abyss #1a2b3c, ecru #F9F8F6, white background
- Preview text from preheader prop
- Heading in serif style
- Content area (rendered HTML from campaign rich text)
- Optional CTA button (if ctaText/ctaUrl provided)
- Footer with:
  - "Vous recevez cet email car vous etes inscrit a la newsletter PleinCap."
  - Unsubscribe link: "Se desinscrire" pointing to unsubscribeUrl
  - Company info: "PleinCap Croisieres - Voyages culturels de luxe"
- Tracking pixel: `<Img src="${baseUrl}/api/tracking/pixel.gif?c=${campaignId}&s=${subscriberId}" width="1" height="1" alt="" />` (tracking routes will be created in Plan 03, but include pixel now for forward compatibility)

Export both the component AND a `renderCampaignEmail(props): string` function using `render()` from @react-email/render.

**Step 2: Create sendCampaign job task** at `src/payload/jobs/sendCampaign.ts`

IMPORTANT: Check Payload 3.x jobs queue API carefully. The task definition may use `TaskConfig` type from payload. The research shows this pattern:

```typescript
import type { TaskConfig } from 'payload'
```

Define the task with:
- slug: 'sendCampaign'
- inputSchema: array with campaignId field (or use Payload's JSON schema format)
- handler function that receives `{ input, req }`:

Handler logic:
1. Get campaign by ID: `req.payload.findByID({ collection: 'campaigns', id: input.campaignId })`
2. Get all active subscribers: `req.payload.find({ collection: 'subscribers', where: { status: { equals: 'active' } }, limit: 0, pagination: false })`
3. Create CampaignSend record with status 'sending', totalRecipients, startedAt
4. Get email adapter: `getEmailAdapter()`
5. Extract plain text from campaign richText content (simple helper: strip HTML tags for text fallback)
6. Process subscribers in batches of 50:
   - For each subscriber, render CampaignTemplate with:
     - heading: campaign.subject
     - content: serialized HTML from campaign.content (use a simple richText-to-HTML helper or serialize from Lexical)
     - unsubscribeUrl: `${baseUrl}/api/newsletter/unsubscribe?token=${subscriber.unsubscribeToken}`
     - campaignId and subscriberId for tracking
   - Send via emailAdapter.send() (not sendBatch, to personalize unsubscribe links per subscriber)
   - Track sent/failed counts
   - Update CampaignSend progress every batch
7. After all batches:
   - Update CampaignSend: status 'completed', completedAt
   - Update Campaign: status 'sent', sentAt, sentCount, failedCount
8. On error:
   - Update CampaignSend: status 'failed', errorLog
   - Update Campaign: status 'failed'

For rich text to HTML conversion: Payload's Lexical editor stores content as JSON. Use a simple utility that checks if content is a Lexical JSON structure and converts it to basic HTML (paragraphs, headings, bold, italic, links). If the content is already a string, use it directly. Keep this utility simple -- it only needs to handle the basic Lexical node types (paragraph, heading, text with format, link).

**Step 3: Configure jobs queue in payload.config.ts**

Add jobs configuration to the buildConfig call:
```typescript
jobs: {
  tasks: [sendCampaign],
}
```

Import the sendCampaign task from './src/payload/jobs/sendCampaign'.

NOTE: Payload 3.x jobs queue API may differ from the research examples. Check the actual Payload 3.76.1 API. The key requirement is:
- Task is registered in config
- Task can be queued via `payload.jobs.queue()` in the Campaigns afterChange hook
- Task runs in background (not blocking the API response)

If Payload 3.76.1 does not support the jobs queue API shown in research, fall back to a simpler approach:
- Create an API route `/api/admin/campaigns/send/route.ts` that handles sending
- Call it from the afterChange hook using fetch() in a fire-and-forget pattern (don't await)
- This maintains the async behavior requirement

Document which approach was used in the SUMMARY.
  </action>
  <verify>
Run `npm run build` and confirm no TypeScript errors. Verify:
1. CampaignTemplate renders valid HTML with unsubscribe link
2. sendCampaign task is properly defined and registered
3. Campaigns afterChange hook references the task correctly
4. payload.config.ts includes jobs configuration (or fallback API route)
  </verify>
  <done>
Campaign email template renders PleinCap-branded emails with personalized unsubscribe links. Background sending task processes subscribers in batches of 50 with progress tracking. Campaigns afterChange hook triggers sending when status becomes 'ready-to-send'. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. Campaigns collection has tabs layout with Contenu/Envoi/Statistiques
3. CampaignSends collection tracks send progress
4. Campaign status flow: draft -> ready-to-send -> sending -> sent
5. afterChange hook only triggers on first status change to 'ready-to-send'
6. sendCampaign task sends personalized emails with unsubscribe links
7. Every email includes unsubscribe link (GDPR requirement)
</verification>

<success_criteria>
- Admin can create campaigns with name, subject, content, preheader, template selection
- Setting status to 'ready-to-send' triggers background email sending
- Each subscriber receives a personalized email with their unsubscribe link
- Send progress is tracked in CampaignSends (sent/failed counts, status)
- Campaign status automatically updates to 'sent' when complete or 'failed' on error
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-newsletter-foundation/04-02-SUMMARY.md`
</output>
