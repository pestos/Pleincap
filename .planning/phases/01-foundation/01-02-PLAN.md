---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - package.json
  - package-lock.json
  - payload.config.ts
  - next.config.mjs
  - docker-compose.yml
  - .env
  - .env.example
  - .gitignore
  - src/app/(frontend)/layout.tsx
  - src/app/(frontend)/page.tsx
  - src/app/(frontend)/globals.css
  - src/app/(payload)/admin/[[...segments]]/page.tsx
  - src/app/(payload)/admin/importMap.js
  - src/app/(payload)/api/[...slug]/route.ts
  - src/app/(payload)/layout.tsx
  - src/app/(payload)/custom.scss
autonomous: true

user_setup:
  - service: PostgreSQL (Docker)
    why: "Payload CMS requires a running PostgreSQL database"
    env_vars:
      - name: DATABASE_URL
        source: "Auto-configured via docker-compose.yml (postgresql://postgres:postgres@localhost:5432/pleincap)"
    dashboard_config:
      - task: "Install Docker Desktop if not already installed"
        location: "https://www.docker.com/products/docker-desktop/"
      - task: "Start the database with: docker-compose up -d"
        location: "Project root directory"

must_haves:
  truths:
    - "Payload CMS packages are installed and payload.config.ts exists"
    - "PostgreSQL database is running via Docker Compose"
    - "Existing frontend pages are in (frontend) route group and unchanged"
    - "Payload admin panel route exists at /admin"
    - "Payload API route exists at /api/*"
    - "No CSS bleed between frontend and admin panel"
  artifacts:
    - path: "payload.config.ts"
      provides: "Payload CMS configuration with PostgreSQL adapter"
      contains: "buildConfig"
      min_lines: 20
    - path: "docker-compose.yml"
      provides: "PostgreSQL development database"
      contains: "postgres"
      min_lines: 10
    - path: ".env"
      provides: "Environment variables for database and Payload"
      contains: "DATABASE_URL"
    - path: "src/app/(frontend)/layout.tsx"
      provides: "Frontend layout wrapper (moved from src/app/layout.tsx content)"
      min_lines: 5
    - path: "src/app/(payload)/admin/[[...segments]]/page.tsx"
      provides: "Payload admin panel catch-all route"
      contains: "RootPage"
    - path: "src/app/(payload)/api/[...slug]/route.ts"
      provides: "Payload REST API route"
      contains: "REST_GET"
  key_links:
    - from: "payload.config.ts"
      to: ".env"
      via: "process.env.DATABASE_URL"
      pattern: "process\\.env\\.DATABASE_URL"
    - from: "next.config.mjs"
      to: "payload.config.ts"
      via: "withPayload wrapper"
      pattern: "withPayload"
    - from: "src/app/(payload)/admin/[[...segments]]/page.tsx"
      to: "payload.config.ts"
      via: "@payload-config alias"
      pattern: "@payload-config"
---

<objective>
Install Payload CMS 3.0 with PostgreSQL adapter, restructure the project into (frontend)/(payload) route groups for CSS isolation, and set up Docker Compose for local PostgreSQL.

Purpose: This is the core infrastructure plan. It installs all Payload packages, creates the database setup, moves existing pages into an isolated route group to prevent CSS bleed from Payload's admin panel, and wires everything together via payload.config.ts and next.config.mjs.

Output: A project with Payload CMS installed, PostgreSQL database running, route groups established, and the dev server loading both frontend pages and the /admin panel.
</objective>

<execution_context>
@/Users/fredericgueirard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fredericgueirard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@package.json
@next.config.mjs
@src/app/layout.tsx
@src/app/globals.css
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Payload CMS and set up PostgreSQL with Docker Compose</name>
  <files>package.json, package-lock.json, payload.config.ts, docker-compose.yml, .env, .env.example, .gitignore, next.config.mjs, tsconfig.json</files>
  <action>
1. **Install Payload CMS packages:**
   ```bash
   npm install payload @payloadcms/db-postgres @payloadcms/richtext-lexical @payloadcms/next sharp graphql
   ```

2. **Create `docker-compose.yml`** at project root:
   ```yaml
   version: '3.8'
   services:
     postgres:
       image: postgres:16-alpine
       restart: unless-stopped
       ports:
         - "5432:5432"
       environment:
         POSTGRES_USER: postgres
         POSTGRES_PASSWORD: postgres
         POSTGRES_DB: pleincap
       volumes:
         - pgdata:/var/lib/postgresql/data
   volumes:
     pgdata:
   ```

3. **Create `.env`** at project root:
   ```
   DATABASE_URL=postgresql://postgres:postgres@localhost:5432/pleincap
   PAYLOAD_SECRET=pleincap-dev-secret-key-change-in-production-min-32-chars
   NEXT_PUBLIC_SERVER_URL=http://localhost:3000
   ```

4. **Create `.env.example`** (committed to git, no secrets):
   ```
   DATABASE_URL=postgresql://postgres:postgres@localhost:5432/pleincap
   PAYLOAD_SECRET=change-me-to-random-string-min-32-characters
   NEXT_PUBLIC_SERVER_URL=http://localhost:3000
   ```

5. **Update `.gitignore`** to include:
   - `.env` (if not already present)
   - `public/media/` (for uploaded files)

6. **Create `payload.config.ts`** at project root:
   ```typescript
   import { buildConfig } from 'payload'
   import { postgresAdapter } from '@payloadcms/db-postgres'
   import { lexicalEditor } from '@payloadcms/richtext-lexical'
   import path from 'path'
   import { fileURLToPath } from 'url'

   const filename = fileURLToPath(import.meta.url)
   const dirname = path.dirname(filename)

   export default buildConfig({
     serverURL: process.env.NEXT_PUBLIC_SERVER_URL || 'http://localhost:3000',

     admin: {
       user: 'users',
       importMap: {
         baseDir: path.resolve(dirname),
       },
     },

     collections: [
       // Collections will be added in Plan 03
     ],

     editor: lexicalEditor({}),

     db: postgresAdapter({
       pool: {
         connectionString: process.env.DATABASE_URL,
       },
       push: process.env.NODE_ENV !== 'production',
     }),

     typescript: {
       outputFile: path.resolve(dirname, 'payload-types.ts'),
     },

     secret: process.env.PAYLOAD_SECRET!,
   })
   ```
   Note: The collections array is empty for now. Plan 03 will add Users and Media collections. The admin panel requires at least a `users` collection (declared in admin.user) to function, so Plan 03 must run before the admin panel is usable.

7. **Update `next.config.mjs`** to wrap with Payload:
   ```javascript
   import { withPayload } from '@payloadcms/next/withPayload'

   /** @type {import('next').NextConfig} */
   const nextConfig = {
     images: {
       remotePatterns: [
         { protocol: 'https', hostname: '**.plein-cap.com' },
         { protocol: 'https', hostname: 'images.unsplash.com' },
         { protocol: 'https', hostname: '**.googleusercontent.com' },
       ],
     },
   }

   export default withPayload(nextConfig)
   ```

8. **Update `tsconfig.json`** to add Payload path alias:
   Add to `compilerOptions.paths`:
   ```json
   "@payload-config": ["./payload.config.ts"]
   ```
   So paths becomes:
   ```json
   "paths": {
     "@/*": ["./src/*"],
     "@payload-config": ["./payload.config.ts"]
   }
   ```
  </action>
  <verify>
    - `ls payload.config.ts` confirms config exists
    - `ls docker-compose.yml` confirms Docker Compose exists
    - `ls .env` confirms env file exists
    - `cat next.config.mjs` shows withPayload wrapper
    - `cat tsconfig.json` shows @payload-config path
    - `npm ls payload` shows payload is installed
  </verify>
  <done>
    - Payload CMS and all required packages installed
    - payload.config.ts exists with PostgreSQL adapter configuration
    - docker-compose.yml exists for local PostgreSQL
    - .env and .env.example exist with required variables
    - next.config.mjs wraps config with withPayload
    - tsconfig.json has @payload-config path alias
  </done>
</task>

<task type="auto">
  <name>Task 2: Restructure into (frontend)/(payload) route groups</name>
  <files>src/app/layout.tsx, src/app/(frontend)/layout.tsx, src/app/(frontend)/page.tsx, src/app/(frontend)/globals.css, src/app/(payload)/admin/[[...segments]]/page.tsx, src/app/(payload)/admin/importMap.js, src/app/(payload)/api/[...slug]/route.ts, src/app/(payload)/layout.tsx, src/app/(payload)/custom.scss</files>
  <action>
1. **Move ALL existing page routes into `src/app/(frontend)/`:**
   Move the following directories and files from `src/app/` to `src/app/(frontend)/`:
   - `page.tsx` (home page)
   - `globals.css`
   - `blog/`
   - `catalogue/`
   - `contact/`
   - `destinations/` (including DestinationsClient.tsx)
   - `equipe/`
   - `escapades-culturelles/`
   - `livre-d-or/`
   - `news-letter/`
   - `nos-bateaux/`
   - `nos-conferenciers/`
   - `notre-histoire/`
   - `orient-express/`
   - `special-groupes/`
   - `visioconference/`
   - `voyages-en-train/`

   Use `mkdir -p src/app/\(frontend\)` then `mv` commands. Route groups use parentheses in directory name but do NOT affect URL paths, so all existing URLs remain identical.

2. **Update `src/app/layout.tsx`** (root layout) to be a minimal shell:
   ```typescript
   import type { Metadata } from 'next'

   export const metadata: Metadata = {
     title: 'Plein Cap Luxury Voyages',
     description: 'Boutique luxury voyages: maritime, fluvial, rail, cultural.',
   }

   export default function RootLayout({
     children,
   }: {
     children: React.ReactNode
   }) {
     return (
       <html lang="fr" className="light">
         <head>
           <link
             rel="stylesheet"
             href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
           />
           <link
             rel="stylesheet"
             href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700,0,900;1,400&family=Inter:wght@300;400;500;600&display=swap"
           />
         </head>
         <body>{children}</body>
       </html>
     )
   }
   ```
   Keep it identical to current layout.tsx. The root layout stays at `src/app/layout.tsx` and wraps BOTH route groups.

3. **Create `src/app/(frontend)/layout.tsx`** for frontend-specific styles:
   ```typescript
   import './globals.css'

   export default function FrontendLayout({
     children,
   }: {
     children: React.ReactNode
   }) {
     return <>{children}</>
   }
   ```
   This layout imports globals.css (Tailwind) ONLY for frontend pages, preventing Tailwind from affecting the Payload admin panel.

4. **Remove the `import './globals.css'` from `src/app/layout.tsx`** (moved to frontend layout).

5. **Create Payload admin panel route at `src/app/(payload)/admin/[[...segments]]/page.tsx`:**
   ```typescript
   /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
   /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
   import type { Metadata } from 'next'

   import config from '@payload-config'
   import { RootPage, generatePageMetadata } from '@payloadcms/next/views'
   import { importMap } from '../importMap'

   type Args = {
     params: Promise<{
       segments: string[]
     }>
     searchParams: Promise<{
       [key: string]: string | string[]
     }>
   }

   export const generateMetadata = ({ params, searchParams }: Args): Promise<Metadata> =>
     generatePageMetadata({ config, params, searchParams })

   const Page = ({ params, searchParams }: Args) =>
     RootPage({ config, params, searchParams, importMap })

   export default Page
   ```

6. **Create `src/app/(payload)/admin/importMap.js`:**
   ```javascript
   /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
   /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
   export const importMap = {}
   ```
   Payload auto-generates this file. Create it empty initially.

7. **Create Payload API route at `src/app/(payload)/api/[...slug]/route.ts`:**
   ```typescript
   /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
   /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
   import { REST_DELETE, REST_GET, REST_PATCH, REST_POST, REST_PUT } from '@payloadcms/next/routes'

   export const GET = REST_GET
   export const POST = REST_POST
   export const DELETE = REST_DELETE
   export const PATCH = REST_PATCH
   export const PUT = REST_PUT
   ```

8. **Create `src/app/(payload)/layout.tsx`** for Payload admin:
   ```typescript
   /* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */
   /* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */
   import type { ServerFunctionClient } from 'payload'

   import config from '@payload-config'
   import { handleServerFunctions, RootLayout } from '@payloadcms/next/layouts'
   import React from 'react'

   import { importMap } from './admin/importMap'
   import './custom.scss'

   type Args = {
     children: React.ReactNode
   }

   const serverFunctions: ServerFunctionClient = async function (args) {
     'use server'
     return handleServerFunctions({
       ...args,
       config,
       importMap,
     })
   }

   const Layout = ({ children }: Args) => (
     <RootLayout config={config} importMap={importMap} serverFunction={serverFunctions}>
       {children}
     </RootLayout>
   )

   export default Layout
   ```

9. **Create `src/app/(payload)/custom.scss`:**
   ```scss
   /* Custom Payload admin styles - add overrides here */
   ```
   This file is the hook point for custom admin styling. Keep it minimal.

10. **Verify no import paths broke.** All `@/components/*` and `@/data/*` imports should still resolve because the `@/*` alias points to `./src/*` and components/data directories are NOT inside route groups.
  </action>
  <verify>
    - `ls src/app/\(frontend\)/page.tsx` confirms home page moved
    - `ls src/app/\(frontend\)/globals.css` confirms CSS moved
    - `ls src/app/\(frontend\)/blog/page.tsx` confirms blog moved
    - `ls src/app/\(payload\)/admin/\[\[...segments\]\]/page.tsx` confirms admin route
    - `ls src/app/\(payload\)/api/\[...slug\]/route.ts` confirms API route
    - `cat src/app/layout.tsx` shows NO globals.css import
    - `cat src/app/\(frontend\)/layout.tsx` shows globals.css import
    - `npm run build` completes without errors (confirms no broken imports)
  </verify>
  <done>
    - All existing pages moved to src/app/(frontend)/ with no URL changes
    - Frontend layout.tsx imports globals.css (Tailwind isolation)
    - Root layout.tsx is a minimal shell (no CSS imports)
    - Payload admin route exists at src/app/(payload)/admin/
    - Payload API route exists at src/app/(payload)/api/
    - Payload admin has its own layout.tsx (CSS isolation from frontend)
    - Build succeeds with no broken imports
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes successfully
2. All existing URLs still work (/, /catalogue, /blog, /destinations, etc.)
3. Payload packages are in node_modules (`npm ls payload`)
4. payload.config.ts exists at project root
5. Route groups are properly structured: `(frontend)` and `(payload)` directories exist
6. No globals.css import in root layout (only in frontend layout)
</verification>

<success_criteria>
- Payload CMS is installed with PostgreSQL adapter configured
- Docker Compose provides local PostgreSQL database
- All existing pages are in (frontend) route group with unchanged URLs
- Payload admin and API routes exist in (payload) route group
- CSS isolation between frontend and admin panel via separate layouts
- Build succeeds with all routes and imports working
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
