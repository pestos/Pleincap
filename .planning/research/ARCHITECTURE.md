# Architecture Research: Payload CMS 3.0 + Next.js 14 Integration

**Research Date:** 2026-02-14
**Project:** PleinCap Travel Website
**Focus:** CMS Integration + Newsletter System Architecture

---

## Executive Summary

Payload CMS 3.0 integrates into Next.js 14 as a **collocated backend** that shares the same Next.js application instance. Unlike traditional headless CMS architectures (separate frontend + backend), Payload 3.0 leverages Next.js App Router to provide both the admin panel and API routes within the same deployment.

**Key Architectural Shift:**
- FROM: Hardcoded content arrays in components
- TO: Database-driven content via Payload collections
- PATTERN: Monolithic Next.js app with integrated CMS capabilities

---

## Major Components

### 1. Core Integration Layer

#### 1.1 Payload Configuration (`payload.config.ts`)
**Location:** Project root
**Purpose:** Central configuration for CMS, database, collections, and plugins

**Key Responsibilities:**
- Define collections (content types)
- Configure database connection (PostgreSQL via Drizzle)
- Set up admin UI customization
- Register plugins (email, media, etc.)
- Define access control rules
- Configure authentication

**Dependencies:**
- None (foundation layer)

**Data Flow:**
- Configuration → All Payload components

---

#### 1.2 Database Layer (PostgreSQL + Drizzle ORM)
**Location:** Configured in `payload.config.ts`, schema auto-generated
**Purpose:** Persistent storage for all CMS content

**Tables Created:**
- `collections.*` - One table per Payload collection
- `payload_preferences` - Admin UI user preferences
- `payload_migrations` - Schema version tracking
- Custom newsletter tables (subscribers, campaigns, templates, stats)

**Data Flow:**
- Payload Collections ↔ Database ↔ Drizzle ORM

---

### 2. Admin Panel Layer

#### 2.1 Admin UI Routes (`/admin/*`)
**Location:** Auto-generated by Payload at `/admin`
**Purpose:** Content management interface

**Key Features:**
- Authentication (login, password reset)
- Collection CRUD interfaces
- Media library management
- User/role management
- Dashboard with analytics

**Access Pattern:**
- Route: `/admin` (protected by authentication)
- Built-in React components from Payload
- Customizable via `admin` config in `payload.config.ts`

**Data Flow:**
- Admin UI → Payload API Routes → Database

---

#### 2.2 Role-Based Access Control (RBAC)
**Location:** Defined in collection configs
**Purpose:** Granular permissions for admin users

**Typical Roles for PleinCap:**
- **Super Admin:** Full access to all content and settings
- **Content Manager:** Edit journeys, destinations, boats, speakers, blog
- **Newsletter Manager:** Manage subscribers, campaigns, templates
- **Editor:** View-only or limited editing rights

**Implementation:**
```typescript
// In collection config
access: {
  create: ({ req: { user } }) => user?.role === 'admin',
  read: () => true, // Public
  update: ({ req: { user } }) => user?.role !== 'viewer',
  delete: ({ req: { user } }) => user?.role === 'admin',
}
```

---

### 3. Collections Architecture

#### 3.1 Content Collections
**Purpose:** Structured content types for the website

**Suggested Collections for PleinCap:**

1. **Journeys** (replaces hardcoded `cruises` array)
   - Fields: title, slug, destination, boat, dates, price, images, description, itinerary, speakers, category, tags
   - Relations: → Destinations, → Boats, → Speakers

2. **Destinations** (replaces hardcoded destinations)
   - Fields: name, slug, country, region, description, highlights, images, mapData
   - Relations: ← Journeys

3. **Boats** (replaces hardcoded boats)
   - Fields: name, slug, description, capacity, cabins, amenities, gallery, specifications
   - Relations: ← Journeys

4. **Speakers** (replaces hardcoded speakers)
   - Fields: name, slug, bio, expertise, photo, cv
   - Relations: ← Journeys

5. **Team** (replaces hardcoded team)
   - Fields: name, role, bio, photo, order

6. **Blog Posts**
   - Fields: title, slug, content, excerpt, coverImage, author, category, tags, publishedAt
   - Relations: → Authors (Team)

7. **Testimonials**
   - Fields: clientName, photo, journey, rating, quote, date, status (approved/pending)
   - Relations: → Journeys (optional)

8. **Media** (built-in)
   - Auto-managed by Payload for all uploads

**Data Flow:**
- Admin Panel → Create/Update Collection Documents → Database
- Next.js Pages → Fetch Collection Data → Render Components

---

#### 3.2 Newsletter System Collections

**Purpose:** Complete newsletter management with segmentation and automation

**Collections:**

1. **Newsletter Subscribers**
   - Fields:
     - email (unique, required)
     - firstName, lastName
     - subscriptionStatus (active, unsubscribed, bounced)
     - segments (array: destinations, boat types, price ranges)
     - preferences (communication frequency, topics)
     - subscriptionDate, unsubscribeDate
     - source (website, manual, import)
   - Hooks: Validate email, double opt-in logic

2. **Newsletter Campaigns**
   - Fields:
     - name, subject, preheader
     - template → Newsletter Templates
     - status (draft, scheduled, sending, sent)
     - scheduledDate, sentDate
     - targetSegments (array of segment filters)
     - content (rich text with journey cards, destination highlights)
   - Relations: → Newsletter Templates, → Journeys (featured)
   - Computed: totalRecipients, openRate, clickRate

3. **Newsletter Templates**
   - Fields:
     - name, type (promotional, informational, transactional)
     - htmlContent (with Lexical editor or blocks)
     - variables (placeholders: {{firstName}}, {{journey.title}})
     - styling (brand colors, fonts)
   - Reusable across campaigns

4. **Campaign Statistics**
   - Fields:
     - campaign → Newsletter Campaigns
     - sent, delivered, opened, clicked, bounced, unsubscribed
     - clickMap (track which links clicked)
     - deviceStats, locationStats
   - Updated via webhook from email provider

5. **Automation Rules** (optional advanced feature)
   - Fields:
     - trigger (new subscriber, journey inquiry, abandoned cart)
     - conditions (segment, delay)
     - action (send template, tag subscriber)
     - active status

**Data Flow:**
- Admin creates Campaign → Selects Template + Segments
- Cron job/API → Query Subscribers by Segment
- Email Service API → Send emails with tracking pixels/links
- Webhooks → Update Campaign Statistics
- Subscribers interact → Update stats and preferences

---

### 4. API Layer

#### 4.1 Payload REST API (`/api/*`)
**Location:** Auto-generated by Payload
**Purpose:** CRUD operations for all collections

**Auto-Generated Endpoints:**
- `GET /api/journeys` - List all journeys (with query params for filtering)
- `GET /api/journeys/:id` - Single journey
- `POST /api/journeys` - Create (authenticated)
- `PATCH /api/journeys/:id` - Update (authenticated)
- `DELETE /api/journeys/:id` - Delete (authenticated)
- Similar for all collections

**Authentication:**
- Admin endpoints require JWT token
- Public read endpoints can be configured per collection

**Data Flow:**
- Next.js Server Components → `fetch('/api/journeys')` → Payload API → Database

---

#### 4.2 Local API (Direct Calls)
**Location:** Used within Server Components
**Purpose:** Faster data fetching without HTTP overhead

**Pattern:**
```typescript
import { getPayloadHMR } from '@payloadcms/next/utilities'
import configPromise from '@payload-config'

// In Server Component
const payload = await getPayloadHMR({ config: configPromise })
const journeys = await payload.find({
  collection: 'journeys',
  where: { status: { equals: 'published' } },
})
```

**Advantages:**
- No network overhead
- Type-safe
- Better performance

**Data Flow:**
- Server Component → Payload Local API → Database

---

#### 4.3 Custom API Routes
**Location:** `src/app/api/` (Next.js App Router)
**Purpose:** Custom business logic not covered by Payload

**Examples for PleinCap:**
- `/api/newsletter/subscribe` - Public subscription with double opt-in
- `/api/newsletter/unsubscribe` - Handle unsubscribe links
- `/api/newsletter/send` - Trigger campaign send (cron job)
- `/api/contact` - Handle contact form submissions
- `/api/journeys/available` - Custom query for available dates

**Data Flow:**
- Frontend → Custom API Route → Payload Local API/External Service → Database

---

### 5. Frontend Integration Layer

#### 5.1 Server Components (Primary Pattern)
**Location:** `src/app/**/page.tsx`
**Purpose:** Fetch and render CMS content

**Migration Pattern:**
```typescript
// BEFORE (hardcoded)
const cruises = [
  { id: 1, title: 'Danube Imperial', ... },
  { id: 2, title: 'Nile Excellence', ... },
]

// AFTER (CMS-driven)
import { getPayloadHMR } from '@payloadcms/next/utilities'
import configPromise from '@payload-config'

export default async function CataloguePage() {
  const payload = await getPayloadHMR({ config: configPromise })
  const { docs: journeys } = await payload.find({
    collection: 'journeys',
    limit: 50,
    sort: '-departureDate',
  })

  return <JourneyList journeys={journeys} />
}
```

**Benefits:**
- Server-side rendering (SEO)
- Direct database access (fast)
- Type-safe with generated types

---

#### 5.2 Client Components (Interactive Features)
**Location:** `src/components/*`
**Purpose:** Interactive filtering, forms, real-time updates

**Pattern:**
```typescript
'use client'

export default function NewsletterForm() {
  const [email, setEmail] = useState('')

  const handleSubmit = async (e) => {
    e.preventDefault()
    const res = await fetch('/api/newsletter/subscribe', {
      method: 'POST',
      body: JSON.stringify({ email }),
    })
    // Handle response
  }

  return <form onSubmit={handleSubmit}>...</form>
}
```

**Use Cases:**
- Newsletter subscription forms
- Journey filters (client-side)
- Contact forms
- Search interfaces

---

#### 5.3 Static Site Generation (SSG) Strategy
**Location:** `generateStaticParams` in pages
**Purpose:** Pre-render content pages for performance

**Pattern:**
```typescript
export async function generateStaticParams() {
  const payload = await getPayloadHMR({ config: configPromise })
  const { docs: journeys } = await payload.find({
    collection: 'journeys',
    limit: 100,
  })

  return journeys.map(journey => ({
    slug: journey.slug,
  }))
}
```

**Revalidation:**
- On-demand: `revalidatePath('/catalogue')` after content updates
- Time-based: `export const revalidate = 3600` (1 hour)

---

### 6. Media Management

#### 6.1 Upload Storage
**Location:** Configured in `payload.config.ts`
**Options:**
- **Local storage:** `/public/media` (dev/small sites)
- **Cloud storage:** AWS S3, Vercel Blob, Cloudinary (production)

**Recommended for VPS:**
- Local storage with CDN proxy (Cloudflare)
- Or S3-compatible object storage (Scaleway, DigitalOcean Spaces)

---

#### 6.2 Image Optimization
**Integration with Next.js Image:**
```typescript
import Image from 'next/image'

<Image
  src={journey.featuredImage.url}
  alt={journey.featuredImage.alt}
  width={journey.featuredImage.width}
  height={journey.featuredImage.height}
  sizes="(max-width: 768px) 100vw, 50vw"
/>
```

**Payload handles:**
- Multiple sizes generation
- WebP conversion
- Metadata extraction
- Alt text storage

---

### 7. Email Service Integration (Newsletter)

#### 7.1 Email Provider Options
**Purpose:** Send transactional and campaign emails

**Options:**
- **Resend** (modern, developer-friendly, 3k emails/month free)
- **SendGrid** (robust, 100 emails/day free)
- **Mailgun** (enterprise, 5k emails/month trial)
- **AWS SES** (cheap, requires more setup)

**Recommendation for PleinCap:** Resend or SendGrid

---

#### 7.2 Email Service Architecture
**Components:**

1. **Email Plugin Configuration**
   ```typescript
   // In payload.config.ts
   import { resendAdapter } from '@payloadcms/email-resend'

   email: resendAdapter({
     defaultFromAddress: 'newsletter@pleincap.com',
     defaultFromName: 'PleinCap Voyages',
     apiKey: process.env.RESEND_API_KEY,
   })
   ```

2. **Campaign Sender Service**
   - Background job (cron or queue)
   - Fetches campaign + subscribers
   - Renders template with personalization
   - Sends in batches (avoid rate limits)
   - Updates statistics

3. **Webhook Handler**
   - Receives delivery/open/click events from email provider
   - Updates Campaign Statistics collection
   - Updates subscriber status (bounced, unsubscribed)

**Data Flow:**
- Admin schedules Campaign → Cron triggers sender → Query Subscribers
- Sender → Email Provider API → Subscriber inboxes
- Subscriber interaction → Webhook → Update Statistics

---

### 8. Authentication & Security

#### 8.1 Admin Authentication
**Built-in by Payload:**
- JWT-based sessions
- Password hashing (bcrypt)
- Password reset flow
- Session management

**Users Collection:**
- Auto-created by Payload
- Fields: email, password, roles
- Can be extended with custom fields

---

#### 8.2 API Security
**Layers:**
- Collection-level access control (read in config)
- API key authentication (optional, for external integrations)
- Rate limiting (custom middleware)
- CORS configuration

**Environment Variables:**
```
PAYLOAD_SECRET=<strong-random-string>
DATABASE_URI=postgresql://...
RESEND_API_KEY=re_...
NEXT_PUBLIC_SERVER_URL=https://pleincap.com
```

---

## Component Boundaries & Interactions

### Boundary Map

```
┌─────────────────────────────────────────────────────────────────┐
│                         NEXT.JS 14 APP                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐         ┌──────────────┐                    │
│  │   /admin/*   │◄────────┤  Admin Panel │                    │
│  │   (Payload)  │         │  Components  │                    │
│  └──────┬───────┘         └──────────────┘                    │
│         │                                                       │
│         ▼                                                       │
│  ┌─────────────────────────────────────────┐                  │
│  │       Payload Collections Layer         │                  │
│  │  (Journeys, Destinations, Boats, etc.)  │                  │
│  └────────┬────────────────────────────────┘                  │
│           │                                                     │
│           ├─────────────┬────────────────────┐                │
│           ▼             ▼                    ▼                │
│  ┌────────────┐  ┌─────────────┐  ┌──────────────────┐       │
│  │ REST API   │  │ Local API   │  │ Custom API       │       │
│  │ /api/*     │  │ (Direct)    │  │ /api/newsletter  │       │
│  └────┬───────┘  └──────┬──────┘  └────────┬─────────┘       │
│       │                 │                   │                 │
│       ▼                 ▼                   ▼                 │
│  ┌─────────────────────────────────────────────────┐          │
│  │           PostgreSQL Database                   │          │
│  │              (Drizzle ORM)                      │          │
│  └─────────────────────────────────────────────────┘          │
│                                                                 │
│  ┌────────────────────────────────────────────────┐            │
│  │      Frontend Layer (Server Components)       │            │
│  │  /catalogue, /destinations, /blog, etc.       │            │
│  │        ▲                                       │            │
│  │        └───── Fetch from Local API            │            │
│  └────────────────────────────────────────────────┘            │
│                                                                 │
│  ┌────────────────────────────────────────────────┐            │
│  │      Client Components (Interactive)           │            │
│  │  Forms, Filters, Newsletter Subscription      │            │
│  │        ▲                                       │            │
│  │        └───── POST to Custom API               │            │
│  └────────────────────────────────────────────────┘            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

External Services:
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│ Email Provider│◄───────│Newsletter    │────────►│Webhook       │
│ (Resend/SG)  │        │Sender Service│         │Handler       │
└──────────────┘         └──────────────┘         └──────────────┘
```

---

## Data Flow Patterns

### 1. Content Creation Flow
```
Admin User (browser)
  → /admin/journeys (Admin UI)
  → Submit form
  → POST /api/journeys (Payload API)
  → Validate + Transform
  → INSERT into PostgreSQL
  → Return success
  → Trigger revalidation (Next.js ISR)
  → /catalogue page regenerated with new journey
```

### 2. Public Content Display Flow
```
User visits /catalogue
  → Next.js Server Component rendered
  → getPayloadHMR().find({ collection: 'journeys' })
  → SELECT from PostgreSQL (via Drizzle)
  → Transform to TypeScript objects
  → Render <JourneyCard> components
  → Send HTML to browser
  → Cache for revalidation period
```

### 3. Newsletter Subscription Flow
```
User submits email (Client Component)
  → POST /api/newsletter/subscribe
  → Custom API Route handler
    → Validate email format
    → Check if subscriber exists
    → If new: CREATE subscriber with status='pending'
    → Send double opt-in email (via Payload email adapter)
    → Return success message
  → User clicks confirmation link
  → GET /api/newsletter/confirm?token=xyz
    → UPDATE subscriber status='active'
    → Return confirmation page
```

### 4. Newsletter Campaign Send Flow
```
Cron job triggers (scheduled time)
  → POST /api/newsletter/send (authenticated)
  → Custom API Route handler
    → Find campaign with status='scheduled' + scheduledDate <= now
    → Update campaign status='sending'
    → Query subscribers matching targetSegments
    → For each batch of 100 subscribers:
      → Render template with personalization
      → Call email provider API (Resend/SendGrid)
      → Track send event
    → Update campaign status='sent' + sentDate
    → Return summary (sent count)
```

### 5. Email Analytics Flow
```
Subscriber opens email (tracking pixel loaded)
  → Email provider registers open
  → Webhook fires to /api/newsletter/webhook
  → Parse event (type='opened', campaignId, subscriberId)
  → UPDATE campaign_statistics.opened += 1
  → Return 200 OK

Subscriber clicks link
  → Email provider registers click
  → Webhook fires to /api/newsletter/webhook
  → Parse event (type='clicked', url, campaignId, subscriberId)
  → UPDATE campaign_statistics.clicked += 1
  → UPDATE campaign_statistics.clickMap[url] += 1
  → Return 200 OK
```

---

## Build Order & Dependencies

### Phase 1: Foundation (Week 1)
**Goal:** Set up Payload + Database

1. Install Payload 3.0 packages
2. Create `payload.config.ts` with basic config
3. Set up PostgreSQL + Drizzle connection
4. Configure admin panel access
5. Create Users collection + first admin user
6. Test admin login at `/admin`

**Deliverables:**
- Working admin panel
- Database connected
- First admin user created

**Dependencies:** None

---

### Phase 2: Core Collections (Week 2)
**Goal:** Migrate hardcoded content to CMS

**Build Order:**
1. **Destinations** (no dependencies)
2. **Boats** (no dependencies)
3. **Speakers** (no dependencies)
4. **Journeys** (depends on: Destinations, Boats, Speakers)
5. **Team** (no dependencies)
6. **Blog Posts** (depends on: Team for authors)
7. **Testimonials** (depends on: Journeys)

**Per Collection:**
- Define schema in `payload.config.ts`
- Run migration to create tables
- Migrate existing data from arrays to database
- Update frontend page to fetch from Payload
- Test CRUD in admin panel

**Deliverables:**
- All collections defined and migrated
- Frontend pages use CMS data
- Admin can edit all content types

**Dependencies:** Phase 1

---

### Phase 3: Frontend Migration (Week 3)
**Goal:** Replace hardcoded content with CMS queries

**Build Order:**
1. Update `/catalogue` - fetch journeys
2. Update `/destinations` - fetch destinations
3. Update `/nos-bateaux` - fetch boats
4. Update `/nos-conferenciers` - fetch speakers
5. Update `/equipe` - fetch team
6. Update `/blog` - fetch blog posts
7. Update `/livre-d-or` - fetch testimonials
8. Add ISR revalidation strategy

**Per Page:**
- Replace hardcoded arrays with `payload.find()`
- Update TypeScript types to use generated Payload types
- Implement static params generation
- Test SSR/SSG rendering
- Configure revalidation

**Deliverables:**
- All pages are CMS-driven
- No hardcoded content arrays remain
- Static generation working

**Dependencies:** Phase 2

---

### Phase 4: Newsletter System - Collections (Week 4)
**Goal:** Build newsletter data layer

**Build Order:**
1. **Newsletter Templates** (no dependencies)
2. **Newsletter Subscribers** (no dependencies)
3. **Newsletter Campaigns** (depends on: Templates)
4. **Campaign Statistics** (depends on: Campaigns)

**Per Collection:**
- Define schema with appropriate fields
- Add validation rules
- Configure access control
- Create admin UI customizations
- Seed with test data

**Deliverables:**
- Newsletter collections created
- Admin can manage templates, subscribers, campaigns
- Test data populated

**Dependencies:** Phase 1

---

### Phase 5: Newsletter System - API (Week 5)
**Goal:** Build newsletter functionality

**Build Order:**
1. **Email Provider Setup**
   - Choose provider (Resend recommended)
   - Configure Payload email adapter
   - Test transactional emails

2. **Public Subscription API**
   - `/api/newsletter/subscribe` - validate, create subscriber
   - `/api/newsletter/confirm` - double opt-in confirmation
   - `/api/newsletter/unsubscribe` - handle unsubscribe
   - Build frontend subscription form component

3. **Campaign Sender Service**
   - `/api/newsletter/send` - manual/cron-triggered send
   - Implement batching logic
   - Implement template rendering with personalization
   - Handle email provider rate limits

4. **Webhook Handler**
   - `/api/newsletter/webhook` - receive delivery events
   - Parse and update statistics
   - Handle bounces and unsubscribes

**Deliverables:**
- Public can subscribe/unsubscribe
- Admin can create and send campaigns
- Email provider integrated
- Basic statistics tracking

**Dependencies:** Phase 4

---

### Phase 6: Newsletter System - Advanced Features (Week 6)
**Goal:** Segmentation, automation, analytics

**Build Order:**
1. **Segmentation**
   - Add segment fields to subscribers
   - Build segment query builder in admin
   - Test targeted campaigns

2. **Analytics Dashboard**
   - Create custom admin dashboard
   - Display campaign performance metrics
   - Add charts (open rate, click rate, growth)

3. **Automation Rules** (optional)
   - Define automation collection
   - Build trigger system (new subscriber, etc.)
   - Implement automation executor

**Deliverables:**
- Campaigns can target specific segments
- Admin dashboard shows newsletter analytics
- Optional: Basic automation working

**Dependencies:** Phase 5

---

### Phase 7: Media & Optimization (Week 7)
**Goal:** Handle uploads and performance

**Build Order:**
1. **Media Storage**
   - Configure upload storage (local or S3)
   - Set up image optimization
   - Migrate existing images to Media collection

2. **Performance**
   - Implement proper image lazy loading
   - Add caching headers
   - Configure CDN (if using)

**Deliverables:**
- All images managed through Payload
- Optimal image formats served
- Fast page loads

**Dependencies:** Phase 3

---

### Phase 8: Access Control & Security (Week 8)
**Goal:** Lock down production

**Build Order:**
1. **RBAC Implementation**
   - Define roles (admin, content-manager, newsletter-manager)
   - Configure collection-level permissions
   - Create role-specific users
   - Test access restrictions

2. **Security Hardening**
   - Set strong PAYLOAD_SECRET
   - Configure CORS properly
   - Add rate limiting to public APIs
   - Secure environment variables
   - Test authentication flows

**Deliverables:**
- Multiple admin roles working
- Security best practices applied
- Production-ready auth

**Dependencies:** All previous phases

---

## Critical Dependencies Summary

**Blocking Dependencies:**
- PostgreSQL must be configured before any collections
- Collections must exist before frontend can fetch from them
- Email provider must be configured before newsletter campaigns can send
- Subscribers collection must exist before subscription API works

**Order-Sensitive Dependencies:**
- Journeys → Destinations, Boats, Speakers (use relations)
- Campaigns → Templates (requires template selection)
- Campaign Statistics → Campaigns (foreign key)
- Blog Posts → Team (author relation)

**Parallel Work Opportunities:**
- Phase 2 collections can be built in parallel (except Journeys)
- Phase 3 page migrations can be done in parallel after Phase 2
- Phase 4 newsletter collections can be built in parallel
- Frontend and backend work can overlap if proper API contracts defined

---

## Key Integration Points

### 1. Payload ↔ Next.js
- **Shared runtime:** Both run in same Node.js process
- **Config import:** `import configPromise from '@payload-config'`
- **API access:** Via Local API (fast) or REST API (flexible)

### 2. Payload ↔ Database
- **ORM:** Drizzle (auto-managed by Payload)
- **Migrations:** Auto-generated, run via `payload migrate`
- **Direct queries:** Use Payload API, not raw SQL (for consistency)

### 3. Frontend ↔ Payload
- **Server Components:** Use Local API (`getPayloadHMR`)
- **Client Components:** Use REST API (`fetch('/api/...')`)
- **Types:** Import generated types from Payload

### 4. Newsletter ↔ Email Provider
- **Adapter pattern:** Payload email plugin wraps provider API
- **Webhooks:** Provider sends events back to app
- **Tracking:** Embedded pixels/links in emails

---

## Technology Choices Rationale

### Why Payload 3.0?
- Native Next.js 14 integration (no separate backend)
- TypeScript-first with auto-generated types
- Flexible collections system
- Built-in admin UI (no custom dashboard needed)
- Active development and modern architecture

### Why PostgreSQL + Drizzle?
- Payload 3.0 default and recommended
- Better performance than MongoDB for relational data
- Strong typing with Drizzle
- ACID compliance for newsletter campaigns

### Why Collocated Architecture?
- Simpler deployment (one app, not two)
- Faster data fetching (no HTTP for internal calls)
- Shared TypeScript types
- Lower hosting costs (one server vs. two)

### Why Email Provider (vs. self-hosted)?
- Deliverability (SPF, DKIM, reputation)
- Analytics built-in (opens, clicks)
- Rate limiting handled
- Compliance (unsubscribe, bounce management)

---

## Risk Mitigation

### Database Migrations
**Risk:** Breaking changes to collections lose data
**Mitigation:**
- Always test migrations locally first
- Use Payload's migration system (versioned)
- Backup database before migrations
- Keep migration files in version control

### Email Deliverability
**Risk:** Newsletters marked as spam
**Mitigation:**
- Proper SPF/DKIM setup
- Use reputable email provider
- Implement double opt-in
- Easy unsubscribe link
- Monitor bounce rates

### Performance at Scale
**Risk:** Slow queries with many journeys/subscribers
**Mitigation:**
- Add database indexes on frequently queried fields
- Use pagination in admin and frontend
- Implement proper caching (ISR)
- Monitor database query performance

### Authentication Security
**Risk:** Admin panel breach
**Mitigation:**
- Strong password requirements
- HTTPS only in production
- Rate limiting on login endpoint
- Consider 2FA for admins (custom hook)

---

## Quality Gates Met

- [x] **Components clearly defined with boundaries**
  - 8 major component layers identified
  - Clear separation between Admin, API, Frontend, Email

- [x] **Data flow direction explicit**
  - 5 detailed data flow patterns documented
  - Arrows show direction in boundary map

- [x] **Build order implications noted**
  - 8 phases with dependencies
  - Parallel work opportunities identified
  - Blocking dependencies called out

---

## Next Steps for Roadmap Planning

Use this architecture to structure your roadmap:

1. **Milestones = Phases** (8 phases → 8 milestones)
2. **Tasks = Build Order Items** (within each phase)
3. **Dependencies = Phase Prerequisites** (Phase N requires Phase N-1)
4. **Parallel Tracks:** Frontend and Backend can overlap after Phase 2

**Suggested Milestone Structure:**
- Milestone 1: Foundation (Phase 1)
- Milestone 2: Content CMS (Phases 2-3 combined)
- Milestone 3: Newsletter Infrastructure (Phases 4-5 combined)
- Milestone 4: Newsletter Advanced (Phase 6)
- Milestone 5: Production Ready (Phases 7-8 combined)

---

**Research Completed By:** Claude (Sonnet 4.5)
**Confidence Level:** High (based on Payload 3.0 official patterns)
**Recommended Review:** Verify email provider choice and VPS hosting requirements
